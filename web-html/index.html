<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chalee DApp - Enhanced</title>
    <script src="./node_modules/ethers/dist/ethers.umd.js"></script>
    <script src="./node_modules/jquery/dist/jquery.min.js"></script>
    <link rel="stylesheet" href="./index.css" />
    <script src="./index.js"></script>
  </head>
  <body>
    <div class="container">
      <!-- å¢å¼ºçš„å¤´éƒ¨ -->
      <div class="header">
        <h1>Chalee DApp</h1>
        <p class="subtitle">ç°ä»£åŒ–çš„ä»¥å¤ªåŠæ™ºèƒ½åˆçº¦äº¤äº’å¹³å°</p>
      </div>

      <!-- é’±åŒ…è¿æ¥å¡ç‰‡ -->
      <div class="card glass" style="margin-bottom: 20px">
        <!-- è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ -->
        <div class="connection-status">
          <div class="status-dot" id="statusDot"></div>
          <span id="connectionText">æœªè¿æ¥</span>
        </div>
        <h3><span class="card-icon">ğŸ”—</span>é’±åŒ…è¿æ¥</h3>
        <div class="input-group">
          <div class="input-row">
            <button id="connectWallet" class="btn btn-primary">
              è¿æ¥ MetaMask
            </button>
            <button id="disconnectWallet" class="btn btn-danger hidden">
              æ–­å¼€è¿æ¥
            </button>
          </div>
        </div>
        <div id="accountInfo" class="account-info hidden"></div>
        <div id="connectionStatus"></div>
        <div id="ownerInfo"></div>
        <div id="balanceDisplay"></div>
      </div>

      <!-- åŠŸèƒ½å¡ç‰‡ç½‘æ ¼ -->
      <div class="grid" id="grid">
        <!-- ä¿¡æ¯ç®¡ç†å¡ç‰‡ -->
        <div class="card glass">
          <h3><span class="card-icon">ğŸ“</span>ä¿¡æ¯ç®¡ç†</h3>
          <div class="input-group">
            <div class="input-row">
              <input type="text" id="nameInput" placeholder="è¾“å…¥å§“å" />
              <input type="number" id="ageInput" placeholder="è¾“å…¥å¹´é¾„" />
            </div>
            <button id="setInfoBtn" class="btn">è®¾ç½®ä¿¡æ¯</button>
          </div>
          <div id="setInfoStatus"></div>

          <div class="input-group" style="margin-top: 25px">
            <button id="getInfoBtn" class="btn btn-success">
              è·å–å½“å‰ä¿¡æ¯
            </button>
          </div>
          <div id="getInfoResult"></div>
        </div>

        <!-- å­˜æ¬¾åŠŸèƒ½å¡ç‰‡ -->
        <div class="card glass">
          <h3><span class="card-icon">ğŸ“¥</span>å­˜å…¥ ETH</h3>
          <div class="input-group">
            <input
              type="number"
              id="depositAmount"
              placeholder="è¾“å…¥å­˜æ¬¾é‡‘é¢ï¼ˆETHï¼‰"
              step="0.001"
              min="0.001"
              class="tooltip"
              data-tooltip="æœ€å°å­˜æ¬¾é‡‘é¢ä¸º 0.001 ETH"
            />
            <button id="depositBtn" class="btn btn-success">å­˜å…¥</button>
          </div>
          <div id="depositStatus"></div>
        </div>

        <!-- ææ¬¾åŠŸèƒ½å¡ç‰‡ -->
        <div class="card glass">
          <h3><span class="card-icon">ğŸ“¤</span>æå– ETH</h3>
          <div class="input-group">
            <input
              type="number"
              id="withdrawAmount"
              placeholder="è¾“å…¥æå–é‡‘é¢ï¼ˆETHï¼‰"
              step="0.001"
              min="0.001"
              class="tooltip"
              data-tooltip="ç¡®ä¿åˆçº¦æœ‰è¶³å¤Ÿä½™é¢"
            />
            <button id="withdrawBtn" class="btn btn-primary">æå–</button>
          </div>
          <div id="withdrawStatus"></div>
        </div>

        <!-- åˆ›å»ºçº¢åŒ…  -->
        <div class="card glass">
          <h3><span class="card-icon">ğŸ</span>åˆ›å»ºçº¢åŒ…</h3>
          <div class="input-group">
            <div class="input-row">
              <!-- çº¢åŒ…é‡‘é¢ -->
              <input
                type="number"
                id="redPacketAmountInput"
                placeholder="è¾“å…¥çº¢åŒ…é‡‘é¢ï¼ˆETHï¼‰"
                step="0.001"
                min="0.001"
              />
              <!-- çº¢åŒ…ä¸ªæ•° -->
              <input
                type="number"
                id="redPacketCountInput"
                placeholder="è¾“å…¥çº¢åŒ…ä¸ªæ•°"
                min="1"
                max="100"
                value="1"
              />
            </div>
            <button id="createRedPacketBtn" class="btn btn-warning">
              åˆ›å»ºçº¢åŒ…
            </button>
          </div>
          <div id="createRedPacketStatus"></div>
        </div>

        <!-- çº¢åŒ…çŠ¶æ€å’ŒæŠ¢çº¢åŒ… -->
        <div class="card glass">
          <h3><span class="card-icon">ğŸ‰</span>çº¢åŒ…çŠ¶æ€</h3>

          <!-- æŸ¥è¯¢çº¢åŒ… -->
          <div class="input-group">
            <div class="input-row">
              <input
                type="number"
                id="queryPacketIdInput"
                placeholder="è¾“å…¥çº¢åŒ…IDæŸ¥è¯¢"
                min="0"
                value="0"
              />
              <button id="queryRedPacketBtn" class="btn btn-info">
                æŸ¥è¯¢çº¢åŒ…
              </button>
            </div>
          </div>

          <!-- çº¢åŒ…è¯¦æƒ…æ˜¾ç¤ºåŒºåŸŸ -->
          <div id="redPacketDetails" class="red-packet-details hidden">
            <div class="packet-info-card">
              <div class="packet-header">
                <h4 id="packetTitle">çº¢åŒ… #0</h4>
                <span id="packetType" class="packet-type-badge">éšæœºçº¢åŒ…</span>
              </div>

              <div class="packet-stats">
                <div class="stat-item">
                  <span class="stat-label">æ€»é‡‘é¢:</span>
                  <span id="packetTotalAmount" class="stat-value">0 ETH</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">å‰©ä½™é‡‘é¢:</span>
                  <span id="packetRemainingAmount" class="stat-value"
                    >0 ETH</span
                  >
                </div>
                <div class="stat-item">
                  <span class="stat-label">æ€»ä¸ªæ•°:</span>
                  <span id="packetTotalCount" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">å‰©ä½™ä¸ªæ•°:</span>
                  <span id="packetRemainingCount" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                  <span class="stat-label">å·²æŠ¢çŠ¶æ€:</span>
                  <span id="packetClaimedStatus" class="stat-value">æœªæŠ¢</span>
                </div>
              </div>

              <!-- è¿›åº¦æ¡ -->
              <div class="progress-container">
                <div class="progress-label">æŠ¢çº¢åŒ…è¿›åº¦</div>
                <div class="progress-bar">
                  <div
                    id="progressFill"
                    class="progress-fill"
                    style="width: 0%"
                  ></div>
                </div>
                <div id="progressText" class="progress-text">0 / 0</div>
              </div>

              <!-- æŠ¢çº¢åŒ…æŒ‰é’® -->
              <div class="action-buttons">
                <button
                  id="claimRedPacketBtn"
                  class="btn btn-success claim-btn hidden"
                >
                  ğŸ æŠ¢çº¢åŒ…
                </button>
                <button id="refreshPacketBtn" class="btn btn-secondary">
                  ğŸ”„ åˆ·æ–°çŠ¶æ€
                </button>
              </div>
            </div>
          </div>

          <!-- çŠ¶æ€ä¿¡æ¯ -->
          <div id="redPacketStatus"></div>
        </div>

        <!-- çº¢åŒ…å†å²è®°å½• -->
        <div class="card glass">
          <h3><span class="card-icon">ğŸ“œ</span>çº¢åŒ…å†å²</h3>
          <div class="input-group">
            <button id="loadHistoryBtn" class="btn btn-info">
              åŠ è½½çº¢åŒ…å†å²
            </button>
          </div>
          <div id="redPacketHistory" class="history-container"></div>
        </div>
      </div>

      <div class="footer-space"></div>
    </div>

    <script>
      // å…¨å±€å˜é‡
      let provider = null;
      let signer = null;
      let contract = null;
      let currentAccount = null;
      let currentPacketId = 0;

      console.log("Chalee DApp - Enhanced Loaded", CONTRACT_ADDRESS);

      // DOM å…ƒç´ 
      const elements = {
        connectWallet: $("#connectWallet"),
        disconnectWallet: $("#disconnectWallet"),
        accountInfo: $("#accountInfo"),
        connectionStatus: $("#connectionStatus"),
        statusDot: $("#statusDot"),
        connectionText: $("#connectionText"),
        ownerInfo: $("#ownerInfo"),
        balanceDisplay: $("#balanceDisplay"),

        // ä¿¡æ¯ç®¡ç†
        nameInput: $("#nameInput"),
        ageInput: $("#ageInput"),
        setInfoBtn: $("#setInfoBtn"),
        setInfoStatus: $("#setInfoStatus"),
        getInfoBtn: $("#getInfoBtn"),
        getInfoResult: $("#getInfoResult"),

        // å­˜æ¬¾
        depositAmount: $("#depositAmount"),
        depositBtn: $("#depositBtn"),
        depositStatus: $("#depositStatus"),

        // ææ¬¾
        withdrawAmount: $("#withdrawAmount"),
        withdrawBtn: $("#withdrawBtn"),
        withdrawStatus: $("#withdrawStatus"),

        grid: $("#grid"),

        // çº¢åŒ…åŠŸèƒ½
        redPacketAmountInput: $("#redPacketAmountInput"),
        redPacketCountInput: $("#redPacketCountInput"),
        createRedPacketBtn: $("#createRedPacketBtn"),
        createRedPacketStatus: $("#createRedPacketStatus"),

        // çº¢åŒ…çŠ¶æ€
        queryPacketIdInput: $("#queryPacketIdInput"),
        queryRedPacketBtn: $("#queryRedPacketBtn"),
        redPacketDetails: $("#redPacketDetails"),
        claimRedPacketBtn: $("#claimRedPacketBtn"),
        refreshPacketBtn: $("#refreshPacketBtn"),
        redPacketStatus: $("#redPacketStatus"),

        // çº¢åŒ…å†å²
        loadHistoryBtn: $("#loadHistoryBtn"),
        redPacketHistory: $("#redPacketHistory"),
      };

      // æ£€æŸ¥ MetaMask
      function checkMetaMask() {
        if (typeof window.ethereum !== "undefined") {
          console.log("MetaMask å·²å®‰è£…");
          return true;
        } else {
          showStatus(
            elements.connectionStatus,
            "è¯·å®‰è£… MetaMask é’±åŒ…æ‰©å±•ï¼",
            "error"
          );
          return false;
        }
      }

      // è¿æ¥é’±åŒ…
      async function connectWallet() {
        if (!checkMetaMask()) return;

        try {
          showStatus(
            elements.connectionStatus,
            "æ­£åœ¨è¿æ¥é’±åŒ…...",
            "info",
            true
          );

          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });

          if (accounts.length === 0) {
            throw new Error("æ²¡æœ‰æ‰¾åˆ°è´¦æˆ·");
          }

          currentAccount = accounts[0];
          provider = new ethers.BrowserProvider(window.ethereum);
          signer = await provider.getSigner();

          contract = new ethers.Contract(
            CONTRACT_ADDRESS,
            CONTRACT_ABI,
            signer
          );

          updateConnectionUI(true);
          updateConnectionStatus(true, currentAccount);
          showStatus(elements.connectionStatus, "é’±åŒ…è¿æ¥æˆåŠŸï¼", "success");

          // è·å–åˆçº¦ä¿¡æ¯
          await Promise.all([getOwnerInfo(), getContractBalance()]);

          // è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…
          await autoQueryLatestPacket();
        } catch (error) {
          console.error("è¿æ¥é’±åŒ…å¤±è´¥:", error);
          showStatus(
            elements.connectionStatus,
            `è¿æ¥å¤±è´¥: ${error.message}`,
            "error"
          );
          updateConnectionStatus(false);
        }
      }

      // æ–­å¼€è¿æ¥
      function disconnectWallet() {
        provider = null;
        signer = null;
        contract = null;
        currentAccount = null;

        updateConnectionUI(false);
        updateConnectionStatus(false);
        showStatus(elements.connectionStatus, "å·²æ–­å¼€é’±åŒ…è¿æ¥", "info");
        clearAllResults();
        elements.redPacketDetails.addClass("hidden");
      }

      // è·å–åˆçº¦æ‰€æœ‰è€…ä¿¡æ¯
      async function getOwnerInfo() {
        if (!contract) return;

        try {
          const owner = await contract.owner();
          const isCurrentUserOwner =
            owner.toLowerCase() === currentAccount.toLowerCase();

          const ownerDisplay = `
            <div class="owner-info ${isCurrentUserOwner ? "owner-badge" : ""}">
              <div style="font-size: 0.9rem; opacity: 0.9;">
                ${
                  isCurrentUserOwner
                    ? "æ‚¨æ‹¥æœ‰åˆçº¦çš„å®Œå…¨æ§åˆ¶æƒ"
                    : "æ‚¨ä¸æ˜¯åˆçº¦æ‰€æœ‰è€…ï¼ŒæŸäº›åŠŸèƒ½å¯èƒ½å—é™"
                }
              </div>
            </div>
          `;

          elements.ownerInfo.html(ownerDisplay);

          const ownerCardDisplay = `
          <!-- æ‰€æœ‰è€…æ“ä½œå¡ç‰‡ -->
        <div class="card glass" id="ownerCard">
          <h3><span class="card-icon">ğŸ†</span>æ‰€æœ‰è€…æ“ä½œ</h3>
          <div class="input-group">
            <button id="transferToOwnerBtn" class="btn btn-warning tooltip" data-tooltip="åªæœ‰åˆçº¦æ‰€æœ‰è€…å¯ä»¥æ‰§è¡Œæ­¤æ“ä½œ">
              è½¬ç§»æ‰€æœ‰ä½™é¢åˆ°åˆçº¦æ‰€æœ‰è€…
            </button>
            <button id="resetPacketCountBtn" class="btn btn-info tooltip" data-tooltip="é‡ç½®çº¢åŒ…è®¡æ•°å™¨ï¼ˆä»…æµ‹è¯•ç”¨ï¼‰">
              é‡ç½®çº¢åŒ…è®¡æ•°å™¨
            </button>
          </div>
          <div id="transferToOwnerStatus"></div>
        </div>
          `;

          // æ§åˆ¶æ‰€æœ‰è€…æ“ä½œå¡ç‰‡æ˜¾ç¤º
          if (isCurrentUserOwner) {
            $("#ownerCard").remove();
            elements.grid.append(ownerCardDisplay);
            $("#transferToOwnerBtn").on("click", transferToOwner);
            $("#resetPacketCountBtn").on("click", resetPacketCount);
          } else {
            $("#ownerCard").remove();
          }
        } catch (error) {
          console.error("è·å–æ‰€æœ‰è€…ä¿¡æ¯å¤±è´¥:", error);
          showStatus(
            elements.ownerInfo,
            `è·å–æ‰€æœ‰è€…ä¿¡æ¯å¤±è´¥: ${error.message}`,
            "error"
          );
        }
      }

      // è·å–åˆçº¦ä½™é¢
      async function getContractBalance() {
        if (!contract) return;

        try {
          const balance = await contract.getBalance();
          const balanceInEth = formatEth(balance);

          elements.balanceDisplay.html(`
            <div class="balance-display">
              <div class="balance-amount">Î ${balanceInEth}</div>
              <div class="balance-label">åˆçº¦å½“å‰ä½™é¢</div>
            </div>
          `);
        } catch (error) {
          console.error("è·å–ä½™é¢å¤±è´¥:", error);
          showStatus(
            elements.balanceDisplay,
            `è·å–ä½™é¢å¤±è´¥: ${error.message}`,
            "error"
          );
        }
      }

      // è®¾ç½®ä¿¡æ¯
      async function setInfo() {
        if (!contract) {
          showStatus(elements.setInfoStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const name = elements.nameInput.val().trim();
        const age = parseInt(elements.ageInput.val());

        if (!name || isNaN(age) || age < 0) {
          showStatus(elements.setInfoStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„å§“åå’Œå¹´é¾„", "error");
          return;
        }

        try {
          showStatus(elements.setInfoStatus, "æ­£åœ¨è®¾ç½®ä¿¡æ¯...", "info", true);

          const tx = await contract.setInfo(name, age);
          showStatus(
            elements.setInfoStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.setInfoStatus,
            `è®¾ç½®æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.nameInput.val("");
          elements.ageInput.val("");
        } catch (error) {
          console.error("è®¾ç½®ä¿¡æ¯å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          }

          showStatus(
            elements.setInfoStatus,
            `è®¾ç½®å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // è·å–ä¿¡æ¯
      async function getInfo() {
        if (!contract) {
          showStatus(elements.getInfoResult, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(elements.getInfoResult, "æ­£åœ¨è·å–ä¿¡æ¯...", "info", true);
          const result = await contract.getInfo();
          const [name, age] = result;

          if (name && age.toString() !== "0") {
            showStatus(
              elements.getInfoResult,
              `å½“å‰ä¿¡æ¯ - å§“å: "${name}", å¹´é¾„: ${age.toString()}`,
              "success"
            );
          } else {
            showStatus(elements.getInfoResult, "æš‚æ— ä¿¡æ¯æˆ–ä¿¡æ¯ä¸ºç©º", "warning");
          }
        } catch (error) {
          console.error("è·å–ä¿¡æ¯å¤±è´¥:", error);
          showStatus(
            elements.getInfoResult,
            `è·å–å¤±è´¥: ${error.message}`,
            "error"
          );
        }
      }

      // å­˜å…¥ETH
      async function depositEth() {
        if (!contract) {
          showStatus(elements.depositStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.depositAmount.val();

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          showStatus(elements.depositStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„å­˜æ¬¾é‡‘é¢", "error");
          return;
        }

        try {
          showStatus(
            elements.depositStatus,
            `æ­£åœ¨å­˜å…¥ ${amount} ETH...`,
            "info",
            true
          );

          const amountWei = parseEth(amount);
          const tx = await contract.deposit({ value: amountWei });

          showStatus(
            elements.depositStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.depositStatus,
            `å­˜æ¬¾æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.depositAmount.val("");
          await getContractBalance();
        } catch (error) {
          console.error("å­˜æ¬¾å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜äº¤æ˜“è´¹ç”¨";
          }

          showStatus(
            elements.depositStatus,
            `å­˜æ¬¾å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // æå–ETH
      async function withdrawEth() {
        if (!contract) {
          showStatus(elements.withdrawStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.withdrawAmount.val();

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          showStatus(elements.withdrawStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„æå–é‡‘é¢", "error");
          return;
        }

        try {
          showStatus(
            elements.withdrawStatus,
            `æ­£åœ¨æå– ${amount} ETH...`,
            "info",
            true
          );

          const amountWei = parseEth(amount);
          const tx = await contract.withdraw(amountWei);

          showStatus(
            elements.withdrawStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.withdrawStatus,
            `æå–æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.withdrawAmount.val("");
          await getContractBalance();
        } catch (error) {
          console.error("æå–å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          } else if (error.message.includes("Insufficient balance")) {
            errorMessage = "åˆçº¦ä½™é¢ä¸è¶³";
          }

          showStatus(
            elements.withdrawStatus,
            `æå–å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // è½¬ç§»åˆ°æ‰€æœ‰è€…
      async function transferToOwner() {
        if (!contract) {
          showStatus(elements.transferToOwnerStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(
            elements.transferToOwnerStatus,
            "æ­£åœ¨è½¬ç§»èµ„é‡‘åˆ°æ‰€æœ‰è€…...",
            "info",
            true
          );

          const tx = await contract.transferToOwner();
          showStatus(
            elements.transferToOwnerStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.transferToOwnerStatus,
            `è½¬ç§»æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          await getContractBalance();
        } catch (error) {
          console.error("è½¬ç§»å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("Only the owner")) {
            errorMessage = "åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ";
          } else if (error.message.includes("No balance")) {
            errorMessage = "åˆçº¦æ²¡æœ‰ä½™é¢å¯è½¬ç§»";
          }

          showStatus(
            elements.transferToOwnerStatus,
            `è½¬ç§»å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // é‡ç½®çº¢åŒ…è®¡æ•°å™¨
      async function resetPacketCount() {
        if (!contract) {
          showStatus(elements.transferToOwnerStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(
            elements.transferToOwnerStatus,
            "æ­£åœ¨é‡ç½®çº¢åŒ…è®¡æ•°å™¨...",
            "info",
            true
          );

          const tx = await contract.resetPacketCount();
          showStatus(
            elements.transferToOwnerStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.transferToOwnerStatus,
            `é‡ç½®æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );
        } catch (error) {
          console.error("é‡ç½®å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("Only owner")) {
            errorMessage = "åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ";
          }

          showStatus(
            elements.transferToOwnerStatus,
            `é‡ç½®å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // åˆ›å»ºçº¢åŒ… - ä¿®å¤å‚æ•°ä¼ é€’é—®é¢˜
      async function createRedPacket() {
        if (!contract) {
          showStatus(elements.createRedPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.redPacketAmountInput.val();
        const count = parseInt(elements.redPacketCountInput.val());

        try {
          // å‚æ•°éªŒè¯
          validateRedPacketParams(amount, count);

          debugLog("åˆ›å»ºçº¢åŒ…å‚æ•°éªŒè¯", { amount, count, type: typeof count });

          showStatus(
            elements.createRedPacketStatus,
            `æ­£åœ¨åˆ›å»ºçº¢åŒ…...`,
            "info",
            true
          );

          // é‡è¦ï¼šç¡®ä¿å‚æ•°ç±»å‹æ­£ç¡®
          const isEqual = false; // å¸ƒå°”å€¼
          const redPacketCount = count; // æ•´æ•° (1-100)
          const amountWei = parseEth(amount); // BigNumber weiæ ¼å¼

          debugLog("å‘é€äº¤æ˜“å‚æ•°", {
            isEqual,
            redPacketCount,
            amountWei: amountWei.toString(),
            value: amountWei.toString(),
          });

          // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„å‚æ•°é¡ºåºå’Œç±»å‹
          const tx = await contract.sendRedPacket(
            isEqual, // bool
            redPacketCount, // uint8 (1-100)
            amountWei, // uint256 (wei)
            {
              value: amountWei, // å‘é€çš„ETHé‡‘é¢ (weiæ ¼å¼)
              gasLimit: 500000, // å¢åŠ Gasé™åˆ¶
            }
          );

          showStatus(
            elements.createRedPacketStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.createRedPacketStatus,
            `çº¢åŒ…åˆ›å»ºæˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.redPacketAmountInput.val("");
          elements.redPacketCountInput.val("1");

          // æ›´æ–°åˆçº¦ä½™é¢
          await getContractBalance();

          // è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…
          await autoQueryLatestPacket();
        } catch (error) {
          console.error("åˆ›å»ºçº¢åŒ…å¤±è´¥:", error);
          debugLog("åˆ›å»ºçº¢åŒ…é”™è¯¯è¯¦æƒ…", error);

          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          } else if (error.message.includes("Count must be between")) {
            errorMessage = "çº¢åŒ…ä¸ªæ•°å¿…é¡»åœ¨1-100ä¹‹é—´";
          } else if (error.message.includes("You can send at most")) {
            errorMessage = "æ‚¨å·²è¾¾åˆ°çº¢åŒ…å‘é€ä¸Šé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜é‡ç½®";
          }

          showStatus(
            elements.createRedPacketStatus,
            `åˆ›å»ºçº¢åŒ…å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯
      async function queryRedPacket() {
        if (!contract) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const packetId = parseInt(elements.queryPacketIdInput.val());

        if (isNaN(packetId) || packetId < 0) {
          showStatus(elements.redPacketStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ID", "error");
          return;
        }

        try {
          showStatus(
            elements.redPacketStatus,
            "æ­£åœ¨æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯...",
            "info",
            true
          );

          // æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯
          const packetInfo = await contract.getPacketInfo(packetId);
          const [
            isEqual,
            count,
            remainingCount,
            amount,
            remainingAmount,
            hasClaimed,
          ] = packetInfo;

          // æ›´æ–°UI
          updateRedPacketDisplay(packetId, {
            isEqual,
            count: count.toString(),
            remainingCount: remainingCount.toString(),
            amount: formatEth(amount),
            remainingAmount: formatEth(remainingAmount),
            hasClaimed,
          });

          currentPacketId = packetId;
          elements.redPacketDetails.removeClass("hidden");
          showStatus(elements.redPacketStatus, "æŸ¥è¯¢æˆåŠŸï¼", "success");
        } catch (error) {
          console.error("æŸ¥è¯¢çº¢åŒ…å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.message.includes("Invalid packet ID")) {
            errorMessage = "çº¢åŒ…IDä¸å­˜åœ¨";
          }

          showStatus(
            elements.redPacketStatus,
            `æŸ¥è¯¢å¤±è´¥: ${errorMessage}`,
            "error"
          );
          elements.redPacketDetails.addClass("hidden");
        }
      }

      // æ›´æ–°çº¢åŒ…æ˜¾ç¤º
      function updateRedPacketDisplay(packetId, info) {
        // æ›´æ–°åŸºæœ¬ä¿¡æ¯
        $("#packetTitle").text(`çº¢åŒ… #${packetId}`);
        $("#packetType").text(info.isEqual ? "ç­‰é¢çº¢åŒ…" : "éšæœºçº¢åŒ…");
        $("#packetTotalAmount").text(`${info.amount} ETH`);
        $("#packetRemainingAmount").text(`${info.remainingAmount} ETH`);
        $("#packetTotalCount").text(info.count);
        $("#packetRemainingCount").text(info.remainingCount);

        // æ›´æ–°å·²æŠ¢çŠ¶æ€
        const claimedText = info.hasClaimed ? "å·²æŠ¢" : "æœªæŠ¢";
        const claimedClass = info.hasClaimed ? "claimed" : "not-claimed";
        $("#packetClaimedStatus")
          .text(claimedText)
          .removeClass("claimed not-claimed")
          .addClass(claimedClass);

        // æ›´æ–°è¿›åº¦æ¡
        const totalCount = parseInt(info.count);
        const remainingCount = parseInt(info.remainingCount);
        const claimedCount = totalCount - remainingCount;
        const progressPercent =
          totalCount > 0 ? (claimedCount / totalCount) * 100 : 0;

        $("#progressFill").css("width", `${progressPercent}%`);
        $("#progressText").text(`${claimedCount} / ${totalCount}`);

        // æ›´æ–°æŠ¢çº¢åŒ…æŒ‰é’®çŠ¶æ€
        const canClaim =
          !info.hasClaimed &&
          remainingCount > 0 &&
          parseFloat(info.remainingAmount) > 0;

        if (canClaim) {
          elements.claimRedPacketBtn.removeClass("hidden").text("ğŸ æŠ¢çº¢åŒ…");
        } else if (info.hasClaimed) {
          elements.claimRedPacketBtn.addClass("hidden");
        } else if (remainingCount === 0) {
          elements.claimRedPacketBtn
            .removeClass("hidden")
            .text("ğŸ˜¢ çº¢åŒ…å·²æŠ¢å®Œ")
            .prop("disabled", true);
        } else {
          elements.claimRedPacketBtn.addClass("hidden");
        }
      }

      // è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…
      async function autoQueryLatestPacket() {
        if (!contract) return;

        try {
          const latestPacketId = await contract.packetId();
          console.log("autoQueryLatestPacketæœ€æ–°çº¢åŒ…ID:", latestPacketId);
          if (latestPacketId > 0) {
            const targetId = latestPacketId - 1; // packetIdæ˜¯ä¸‹ä¸€ä¸ªè¦åˆ›å»ºçš„IDï¼Œæ‰€ä»¥å‡1
            elements.queryPacketIdInput.val(targetId);
            await queryRedPacket();
          }
        } catch (error) {
          console.log("è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…å¤±è´¥:", error.message);
        }
      }

      // æŠ¢çº¢åŒ…
      async function claimRedPacket() {
        if (!contract) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        if (currentPacketId < 0) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆæŸ¥è¯¢çº¢åŒ…ä¿¡æ¯", "error");
          return;
        }

        try {
          showStatus(elements.redPacketStatus, "æ­£åœ¨æŠ¢çº¢åŒ…...", "info", true);

          const tx = await contract.getRedPacket(currentPacketId, {
            gasLimit: 300000,
          });

          showStatus(
            elements.redPacketStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();

          // è§£æäº‹ä»¶è·å–æŠ¢åˆ°çš„é‡‘é¢
          let claimedAmount = "æœªçŸ¥";
          if (receipt.logs) {
            for (const log of receipt.logs) {
              try {
                const parsedLog = contract.interface.parseLog(log);
                if (parsedLog.name === "PacketClaimed") {
                  claimedAmount = formatEth(parsedLog.args.amount);
                  break;
                }
              } catch (e) {
                // å¿½ç•¥è§£æå¤±è´¥çš„æ—¥å¿—
              }
            }
          }

          showStatus(
            elements.redPacketStatus,
            `æŠ¢çº¢åŒ…æˆåŠŸï¼è·å¾— ${claimedAmount} ETHï¼ŒåŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          // åˆ·æ–°çº¢åŒ…çŠ¶æ€
          await refreshPacketStatus();
        } catch (error) {
          console.error("æŠ¢çº¢åŒ…å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("No remaining red packets")) {
            errorMessage = "çº¢åŒ…å·²è¢«æŠ¢å®Œ";
          } else if (error.message.includes("Already claimed")) {
            errorMessage = "æ‚¨å·²ç»æŠ¢è¿‡è¿™ä¸ªçº¢åŒ…äº†";
          } else if (error.message.includes("Invalid packet ID")) {
            errorMessage = "çº¢åŒ…IDæ— æ•ˆ";
          }

          showStatus(
            elements.redPacketStatus,
            `æŠ¢çº¢åŒ…å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // åˆ·æ–°çº¢åŒ…çŠ¶æ€
      async function refreshPacketStatus() {
        if (currentPacketId >= 0) {
          await queryRedPacket();
        }
      }

      // åŠ è½½çº¢åŒ…å†å²
      async function loadRedPacketHistory() {
        if (!contract) {
          showStatus(elements.redPacketHistory, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          elements.redPacketHistory.html(
            '<div class="loading">æ­£åœ¨åŠ è½½çº¢åŒ…å†å²...</div>'
          );

          // è·å–æœ€æ–°çš„çº¢åŒ…ID
          const latestPacketId = await contract.packetId();

          if (latestPacketId === 0) {
            elements.redPacketHistory.html(
              '<div class="no-data">æš‚æ— çº¢åŒ…å†å²</div>'
            );
            return;
          }

          let historyHtml = '<div class="history-list">';

          // åŠ è½½æœ€è¿‘çš„10ä¸ªçº¢åŒ…ï¼ˆæˆ–å…¨éƒ¨ï¼Œå¦‚æœå°‘äº10ä¸ªï¼‰
          const maxHistory = Math.min(latestPacketId, 10);

          for (
            let i = latestPacketId - 1;
            i >= Math.max(0, latestPacketId - maxHistory);
            i--
          ) {
            try {
              const packetInfo = await contract.getPacketInfo(i);
              const [
                isEqual,
                count,
                remainingCount,
                amount,
                remainingAmount,
                hasClaimed,
              ] = packetInfo;

              const totalCount = count.toString();
              const claimedCount =
                parseInt(totalCount) - parseInt(remainingCount.toString());
              const progressPercent =
                parseInt(totalCount) > 0
                  ? (claimedCount / parseInt(totalCount)) * 100
                  : 0;
              const status =
                parseInt(remainingCount.toString()) === 0
                  ? "å·²æŠ¢å®Œ"
                  : hasClaimed
                  ? "å·²å‚ä¸"
                  : "å¯æŠ¢";
              const statusClass =
                parseInt(remainingCount.toString()) === 0
                  ? "finished"
                  : hasClaimed
                  ? "claimed"
                  : "available";

              historyHtml += `
                <div class="history-item ${statusClass}" onclick="loadPacketDetails(${i})">
                  <div class="history-header">
                    <span class="packet-id">çº¢åŒ… #${i}</span>
                    <span class="packet-status ${statusClass}">${status}</span>
                  </div>
                  <div class="history-details">
                    <div class="detail-item">
                      <span>ç±»å‹: ${isEqual ? "ç­‰é¢" : "éšæœº"}</span>
                      <span>æ€»é¢: ${formatEth(amount)} ETH</span>
                    </div>
                    <div class="detail-item">
                      <span>è¿›åº¦: ${claimedCount}/${totalCount}</span>
                      <span>å‰©ä½™: ${formatEth(remainingAmount)} ETH</span>
                    </div>
                  </div>
                  <div class="progress-bar-small">
                    <div class="progress-fill-small" style="width: ${progressPercent}%"></div>
                  </div>
                </div>
              `;
            } catch (error) {
              console.error(`åŠ è½½çº¢åŒ… #${i} å¤±è´¥:`, error);
            }
          }

          historyHtml += "</div>";
          elements.redPacketHistory.html(historyHtml);
        } catch (error) {
          console.error("åŠ è½½çº¢åŒ…å†å²å¤±è´¥:", error);
          elements.redPacketHistory.html(
            `<div class="error">åŠ è½½å¤±è´¥: ${error.message}</div>`
          );
        }
      }

      // åŠ è½½ç‰¹å®šçº¢åŒ…è¯¦æƒ…
      function loadPacketDetails(packetId) {
        elements.queryPacketIdInput.val(packetId);
        queryRedPacket();
      }

      // è®¾ç½®ä¿¡æ¯
      async function setInfo() {
        if (!contract) {
          showStatus(elements.setInfoStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const name = elements.nameInput.val().trim();
        const age = parseInt(elements.ageInput.val());

        if (!name || isNaN(age) || age < 0) {
          showStatus(elements.setInfoStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„å§“åå’Œå¹´é¾„", "error");
          return;
        }

        try {
          showStatus(elements.setInfoStatus, "æ­£åœ¨è®¾ç½®ä¿¡æ¯...", "info", true);

          const tx = await contract.setInfo(name, age);
          showStatus(
            elements.setInfoStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.setInfoStatus,
            `è®¾ç½®æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.nameInput.val("");
          elements.ageInput.val("");
        } catch (error) {
          console.error("è®¾ç½®ä¿¡æ¯å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          }

          showStatus(
            elements.setInfoStatus,
            `è®¾ç½®å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // è·å–ä¿¡æ¯
      async function getInfo() {
        if (!contract) {
          showStatus(elements.getInfoResult, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(elements.getInfoResult, "æ­£åœ¨è·å–ä¿¡æ¯...", "info", true);
          const result = await contract.getInfo();
          const [name, age] = result;

          if (name && age.toString() !== "0") {
            showStatus(
              elements.getInfoResult,
              `å½“å‰ä¿¡æ¯ - å§“å: "${name}", å¹´é¾„: ${age.toString()}`,
              "success"
            );
          } else {
            showStatus(elements.getInfoResult, "æš‚æ— ä¿¡æ¯æˆ–ä¿¡æ¯ä¸ºç©º", "warning");
          }
        } catch (error) {
          console.error("è·å–ä¿¡æ¯å¤±è´¥:", error);
          showStatus(
            elements.getInfoResult,
            `è·å–å¤±è´¥: ${error.message}`,
            "error"
          );
        }
      }

      // å­˜å…¥ETH
      async function depositEth() {
        if (!contract) {
          showStatus(elements.depositStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.depositAmount.val();

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          showStatus(elements.depositStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„å­˜æ¬¾é‡‘é¢", "error");
          return;
        }

        try {
          showStatus(
            elements.depositStatus,
            `æ­£åœ¨å­˜å…¥ ${amount} ETH...`,
            "info",
            true
          );

          const amountWei = parseEth(amount);
          const tx = await contract.deposit({ value: amountWei });

          showStatus(
            elements.depositStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.depositStatus,
            `å­˜æ¬¾æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.depositAmount.val("");
          await getContractBalance();
        } catch (error) {
          console.error("å­˜æ¬¾å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜äº¤æ˜“è´¹ç”¨";
          }

          showStatus(
            elements.depositStatus,
            `å­˜æ¬¾å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // æå–ETH
      async function withdrawEth() {
        if (!contract) {
          showStatus(elements.withdrawStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.withdrawAmount.val();

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          showStatus(elements.withdrawStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„æå–é‡‘é¢", "error");
          return;
        }

        try {
          showStatus(
            elements.withdrawStatus,
            `æ­£åœ¨æå– ${amount} ETH...`,
            "info",
            true
          );

          const amountWei = parseEth(amount);
          const tx = await contract.withdraw(amountWei);

          showStatus(
            elements.withdrawStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.withdrawStatus,
            `æå–æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.withdrawAmount.val("");
          await getContractBalance();
        } catch (error) {
          console.error("æå–å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          } else if (error.message.includes("Insufficient balance")) {
            errorMessage = "åˆçº¦ä½™é¢ä¸è¶³";
          }

          showStatus(
            elements.withdrawStatus,
            `æå–å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // è½¬ç§»åˆ°æ‰€æœ‰è€…
      async function transferToOwner() {
        if (!contract) {
          showStatus(elements.transferToOwnerStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(
            elements.transferToOwnerStatus,
            "æ­£åœ¨è½¬ç§»èµ„é‡‘åˆ°æ‰€æœ‰è€…...",
            "info",
            true
          );

          const tx = await contract.transferToOwner();
          showStatus(
            elements.transferToOwnerStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.transferToOwnerStatus,
            `è½¬ç§»æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          await getContractBalance();
        } catch (error) {
          console.error("è½¬ç§»å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("Only the owner")) {
            errorMessage = "åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ";
          } else if (error.message.includes("No balance")) {
            errorMessage = "åˆçº¦æ²¡æœ‰ä½™é¢å¯è½¬ç§»";
          }

          showStatus(
            elements.transferToOwnerStatus,
            `è½¬ç§»å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // é‡ç½®çº¢åŒ…è®¡æ•°å™¨
      async function resetPacketCount() {
        if (!contract) {
          showStatus(elements.transferToOwnerStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(
            elements.transferToOwnerStatus,
            "æ­£åœ¨é‡ç½®çº¢åŒ…è®¡æ•°å™¨...",
            "info",
            true
          );

          const tx = await contract.resetPacketCount();
          showStatus(
            elements.transferToOwnerStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.transferToOwnerStatus,
            `é‡ç½®æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );
        } catch (error) {
          console.error("é‡ç½®å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("Only owner")) {
            errorMessage = "åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ";
          }

          showStatus(
            elements.transferToOwnerStatus,
            `é‡ç½®å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // åˆ›å»ºçº¢åŒ… - ä¿®å¤å‚æ•°ä¼ é€’é—®é¢˜
      async function createRedPacket() {
        if (!contract) {
          showStatus(elements.createRedPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.redPacketAmountInput.val();
        const count = parseInt(elements.redPacketCountInput.val());

        try {
          // å‚æ•°éªŒè¯
          validateRedPacketParams(amount, count);

          debugLog("åˆ›å»ºçº¢åŒ…å‚æ•°éªŒè¯", { amount, count, type: typeof count });

          showStatus(
            elements.createRedPacketStatus,
            `æ­£åœ¨åˆ›å»ºçº¢åŒ…...`,
            "info",
            true
          );

          // é‡è¦ï¼šç¡®ä¿å‚æ•°ç±»å‹æ­£ç¡®
          const isEqual = false; // å¸ƒå°”å€¼
          const redPacketCount = count; // æ•´æ•° (1-100)
          const amountWei = parseEth(amount); // BigNumber weiæ ¼å¼

          debugLog("å‘é€äº¤æ˜“å‚æ•°", {
            isEqual,
            redPacketCount,
            amountWei: amountWei.toString(),
            value: amountWei.toString(),
          });

          // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„å‚æ•°é¡ºåºå’Œç±»å‹
          const tx = await contract.sendRedPacket(
            isEqual, // bool
            redPacketCount, // uint8 (1-100)
            amountWei, // uint256 (wei)
            {
              value: amountWei, // å‘é€çš„ETHé‡‘é¢ (weiæ ¼å¼)
              gasLimit: 500000, // å¢åŠ Gasé™åˆ¶
            }
          );

          showStatus(
            elements.createRedPacketStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.createRedPacketStatus,
            `çº¢åŒ…åˆ›å»ºæˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.redPacketAmountInput.val("");
          elements.redPacketCountInput.val("1");

          // æ›´æ–°åˆçº¦ä½™é¢
          await getContractBalance();

          // è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…
          await autoQueryLatestPacket();
        } catch (error) {
          console.error("åˆ›å»ºçº¢åŒ…å¤±è´¥:", error);
          debugLog("åˆ›å»ºçº¢åŒ…é”™è¯¯è¯¦æƒ…", error);

          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          } else if (error.message.includes("Count must be between")) {
            errorMessage = "çº¢åŒ…ä¸ªæ•°å¿…é¡»åœ¨1-100ä¹‹é—´";
          } else if (error.message.includes("You can send at most")) {
            errorMessage = "æ‚¨å·²è¾¾åˆ°çº¢åŒ…å‘é€ä¸Šé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜é‡ç½®";
          }

          showStatus(
            elements.createRedPacketStatus,
            `åˆ›å»ºçº¢åŒ…å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯
      async function queryRedPacket() {
        if (!contract) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const packetId = parseInt(elements.queryPacketIdInput.val());

        if (isNaN(packetId) || packetId < 0) {
          showStatus(elements.redPacketStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ID", "error");
          return;
        }

        try {
          showStatus(
            elements.redPacketStatus,
            "æ­£åœ¨æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯...",
            "info",
            true
          );

          // æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯
          const packetInfo = await contract.getPacketInfo(packetId);
          const [
            isEqual,
            count,
            remainingCount,
            amount,
            remainingAmount,
            hasClaimed,
          ] = packetInfo;

          // æ›´æ–°UI
          updateRedPacketDisplay(packetId, {
            isEqual,
            count: count.toString(),
            remainingCount: remainingCount.toString(),
            amount: formatEth(amount),
            remainingAmount: formatEth(remainingAmount),
            hasClaimed,
          });

          currentPacketId = packetId;
          elements.redPacketDetails.removeClass("hidden");
          showStatus(elements.redPacketStatus, "æŸ¥è¯¢æˆåŠŸï¼", "success");
        } catch (error) {
          console.error("æŸ¥è¯¢çº¢åŒ…å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.message.includes("Invalid packet ID")) {
            errorMessage = "çº¢åŒ…IDä¸å­˜åœ¨";
          }

          showStatus(
            elements.redPacketStatus,
            `æŸ¥è¯¢å¤±è´¥: ${errorMessage}`,
            "error"
          );
          elements.redPacketDetails.addClass("hidden");
        }
      }

      // æ›´æ–°çº¢åŒ…æ˜¾ç¤º
      function updateRedPacketDisplay(packetId, info) {
        // æ›´æ–°åŸºæœ¬ä¿¡æ¯
        $("#packetTitle").text(`çº¢åŒ… #${packetId}`);
        $("#packetType").text(info.isEqual ? "ç­‰é¢çº¢åŒ…" : "éšæœºçº¢åŒ…");
        $("#packetTotalAmount").text(`${info.amount} ETH`);
        $("#packetRemainingAmount").text(`${info.remainingAmount} ETH`);
        $("#packetTotalCount").text(info.count);
        $("#packetRemainingCount").text(info.remainingCount);

        // æ›´æ–°å·²æŠ¢çŠ¶æ€
        const claimedText = info.hasClaimed ? "å·²æŠ¢" : "æœªæŠ¢";
        const claimedClass = info.hasClaimed ? "claimed" : "not-claimed";
        $("#packetClaimedStatus")
          .text(claimedText)
          .removeClass("claimed not-claimed")
          .addClass(claimedClass);

        // æ›´æ–°è¿›åº¦æ¡
        const totalCount = parseInt(info.count);
        const remainingCount = parseInt(info.remainingCount);
        const claimedCount = totalCount - remainingCount;
        const progressPercent =
          totalCount > 0 ? (claimedCount / totalCount) * 100 : 0;

        $("#progressFill").css("width", `${progressPercent}%`);
        $("#progressText").text(`${claimedCount} / ${totalCount}`);

        // æ›´æ–°æŠ¢çº¢åŒ…æŒ‰é’®çŠ¶æ€
        const canClaim =
          !info.hasClaimed &&
          remainingCount > 0 &&
          parseFloat(info.remainingAmount) > 0;

        if (canClaim) {
          elements.claimRedPacketBtn
            .removeClass("hidden")
            .text("ğŸ æŠ¢çº¢åŒ…")
            .prop("disabled", false);
        } else if (info.hasClaimed) {
          elements.claimRedPacketBtn.addClass("hidden");
        } else if (remainingCount === 0) {
          elements.claimRedPacketBtn
            .removeClass("hidden")
            .text("ğŸ˜¢ çº¢åŒ…å·²æŠ¢å®Œ")
            .prop("disabled", true);
        } else {
          elements.claimRedPacketBtn.addClass("hidden");
        }
      }

      // è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…
      async function autoQueryLatestPacket() {
        if (!contract) return;

        try {
          const latestPacketId = await contract.packetId();
          console.log("autoQueryLatestPacketæœ€æ–°çº¢åŒ…ID:", Number(latestPacketId));
          // æ ¼å¼åŒ–çº¢åŒ…IDä¸ºæœ€æ–°çš„çº¢åŒ…ID - 1
          if (Number(latestPacketId) > 0) {
            const targetId = Number(latestPacketId) - 1; // packetIdæ˜¯ä¸‹ä¸€ä¸ªè¦åˆ›å»ºçš„IDï¼Œæ‰€ä»¥å‡1
            elements.queryPacketIdInput.val(targetId);
            await queryRedPacket();
          }
        } catch (error) {
          console.log("è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…å¤±è´¥:", error.message);
        }
      }

      // æŠ¢çº¢åŒ…
      async function claimRedPacket() {
        if (!contract) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        if (currentPacketId < 0) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆæŸ¥è¯¢çº¢åŒ…ä¿¡æ¯", "error");
          return;
        }

        try {
          showStatus(elements.redPacketStatus, "æ­£åœ¨æŠ¢çº¢åŒ…...", "info", true);

          const tx = await contract.getRedPacket(currentPacketId, {
            gasLimit: 300000,
          });

          showStatus(
            elements.redPacketStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();

          // è§£æäº‹ä»¶è·å–æŠ¢åˆ°çš„é‡‘é¢
          let claimedAmount = "æœªçŸ¥";
          if (receipt.logs) {
            for (const log of receipt.logs) {
              try {
                const parsedLog = contract.interface.parseLog(log);
                if (parsedLog.name === "PacketClaimed") {
                  claimedAmount = formatEth(parsedLog.args.amount);
                  break;
                }
              } catch (e) {
                // å¿½ç•¥è§£æå¤±è´¥çš„æ—¥å¿—
              }
            }
          }

          showStatus(
            elements.redPacketStatus,
            `æŠ¢çº¢åŒ…æˆåŠŸï¼è·å¾— ${claimedAmount} ETHï¼ŒåŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          // åˆ·æ–°çº¢åŒ…çŠ¶æ€
          await refreshPacketStatus();
        } catch (error) {
          console.error("æŠ¢çº¢åŒ…å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("No remaining red packets")) {
            errorMessage = "çº¢åŒ…å·²è¢«æŠ¢å®Œ";
          } else if (error.message.includes("Already claimed")) {
            errorMessage = "æ‚¨å·²ç»æŠ¢è¿‡è¿™ä¸ªçº¢åŒ…äº†";
          } else if (error.message.includes("Invalid packet ID")) {
            errorMessage = "çº¢åŒ…IDæ— æ•ˆ";
          }

          showStatus(
            elements.redPacketStatus,
            `æŠ¢çº¢åŒ…å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // åˆ·æ–°çº¢åŒ…çŠ¶æ€
      async function refreshPacketStatus() {
        if (currentPacketId >= 0) {
          await queryRedPacket();
        }
      }

      // åŠ è½½çº¢åŒ…å†å²
      async function loadRedPacketHistory() {
        if (!contract) {
          elements.redPacketHistory.html(
            '<div class="error">è¯·å…ˆè¿æ¥é’±åŒ…</div>'
          );
          return;
        }

        try {
          elements.redPacketHistory.html(
            '<div class="loading">æ­£åœ¨åŠ è½½çº¢åŒ…å†å²...</div>'
          );

          // è·å–æœ€æ–°çš„çº¢åŒ…ID
          const latestPacketId = Number(await contract.packetId());

          if (latestPacketId === 0) {
            elements.redPacketHistory.html(
              '<div class="no-data">æš‚æ— çº¢åŒ…å†å²</div>'
            );
            return;
          }

          let historyHtml = '<div class="history-list">';

          // åŠ è½½æœ€è¿‘çš„10ä¸ªçº¢åŒ…ï¼ˆæˆ–å…¨éƒ¨ï¼Œå¦‚æœå°‘äº10ä¸ªï¼‰
          const maxHistory = Math.min(latestPacketId, 10);

          console.log("åŠ è½½çº¢åŒ…å†å²ï¼Œæœ€æ–°çº¢åŒ…ID:", latestPacketId);
          console.log("åŠ è½½çº¢åŒ…å†å²ï¼Œæœ€å¤§å†å²æ•°é‡:", maxHistory);

          for (
            let i = latestPacketId-1;
            i >= Math.max(0, latestPacketId - maxHistory);
            i--
          ) {
            try {
              const packetInfo = await contract.getPacketInfo(i);
              const [
                isEqual,
                count,
                remainingCount,
                amount,
                remainingAmount,
                hasClaimed,
              ] = packetInfo;

              const totalCount = count.toString();
              const claimedCount =
                parseInt(totalCount) - parseInt(remainingCount.toString());
              const progressPercent =
                parseInt(totalCount) > 0
                  ? (claimedCount / parseInt(totalCount)) * 100
                  : 0;
              const status =
                parseInt(remainingCount.toString()) === 0
                  ? "å·²æŠ¢å®Œ"
                  : hasClaimed
                  ? "å·²å‚ä¸"
                  : "å¯æŠ¢";
              const statusClass =
                parseInt(remainingCount.toString()) === 0
                  ? "finished"
                  : hasClaimed
                  ? "claimed"
                  : "available";

              historyHtml += `
                <div class="history-item ${statusClass}" onclick="loadPacketDetails(${i})">
                  <div class="history-header">
                    <span class="packet-id">çº¢åŒ… #${i}</span>
                    <span class="packet-status ${statusClass}">${status}</span>
                  </div>
                  <div class="history-details">
                    <div class="detail-item">
                      <span>ç±»å‹: ${isEqual ? "ç­‰é¢" : "éšæœº"}</span>
                      <span>æ€»é¢: ${formatEth(amount)} ETH</span>
                    </div>
                    <div class="detail-item">
                      <span>è¿›åº¦: ${claimedCount}/${totalCount}</span>
                      <span>å‰©ä½™: ${formatEth(remainingAmount)} ETH</span>
                    </div>
                  </div>
                  <div class="progress-bar-small">
                    <div class="progress-fill-small" style="width: ${progressPercent}%"></div>
                  </div>
                </div>
                <hr/>
              `;
            } catch (error) {
              console.error(`åŠ è½½çº¢åŒ… #${i} å¤±è´¥:`, error);
            }
          }

          historyHtml += "</div>";
          elements.redPacketHistory.html(historyHtml);
        } catch (error) {
          console.error("åŠ è½½çº¢åŒ…å†å²å¤±è´¥:", error);
          elements.redPacketHistory.html(
            `<div class="error">åŠ è½½å¤±è´¥: ${error.message}</div>`
          );
        }
      }

      // åŠ è½½ç‰¹å®šçº¢åŒ…è¯¦æƒ…
      function loadPacketDetails(packetId) {
        elements.queryPacketIdInput.val(packetId);
        queryRedPacket();
      }

      // ç›‘å¬è´¦æˆ·å’Œç½‘ç»œå˜åŒ–
      if (window.ethereum) {
        window.ethereum.on("accountsChanged", (accounts) => {
          if (accounts.length === 0) {
            disconnectWallet();
          } else if (currentAccount && accounts[0] !== currentAccount) {
            connectWallet();
          }
        });

        window.ethereum.on("chainChanged", () => {
          window.location.reload();
        });
      }

      // äº‹ä»¶ç›‘å¬å™¨è®¾ç½®
      $(document).ready(function () {
        // ç»‘å®šäº‹ä»¶
        elements.connectWallet.on("click", connectWallet);
        elements.disconnectWallet.on("click", disconnectWallet);
        elements.setInfoBtn.on("click", setInfo);
        elements.getInfoBtn.on("click", getInfo);
        elements.depositBtn.on("click", depositEth);
        elements.withdrawBtn.on("click", withdrawEth);
        elements.createRedPacketBtn.on("click", createRedPacket);

        // çº¢åŒ…ç›¸å…³äº‹ä»¶
        elements.queryRedPacketBtn.on("click", queryRedPacket);
        elements.claimRedPacketBtn.on("click", claimRedPacket);
        elements.refreshPacketBtn.on("click", refreshPacketStatus);
        elements.loadHistoryBtn.on("click", loadRedPacketHistory);

        // å›è½¦é”®æ”¯æŒ
        elements.nameInput.add(elements.ageInput).on("keypress", function (e) {
          if (e.which === 13) setInfo();
        });

        elements.depositAmount.on("keypress", function (e) {
          if (e.which === 13) depositEth();
        });

        elements.withdrawAmount.on("keypress", function (e) {
          if (e.which === 13) withdrawEth();
        });

        elements.redPacketAmountInput
          .add(elements.redPacketCountInput)
          .on("keypress", function (e) {
            if (e.which === 13) createRedPacket();
          });

        elements.queryPacketIdInput.on("keypress", function (e) {
          if (e.which === 13) queryRedPacket();
        });

        // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
        if (checkMetaMask()) {
          window.ethereum
            .request({ method: "eth_accounts" })
            .then((accounts) => {
              if (accounts.length > 0) {
                connectWallet();
              }
            })
            .catch((error) => {
              console.error("æ£€æŸ¥è¿æ¥çŠ¶æ€å¤±è´¥:", error);
            });
        }
      });
    </script>
  </body>
</html>
