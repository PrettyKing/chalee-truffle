            </div>
          `);
        } catch (error) {
          console.error("è·å–ä½™é¢å¤±è´¥:", error);
          showStatus(
            elements.balanceDisplay,
            `è·å–ä½™é¢å¤±è´¥: ${error.message}`,
            "error"
          );
        }
      }

      // è®¾ç½®ä¿¡æ¯
      async function setInfo() {
        if (!contract) {
          showStatus(elements.setInfoStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const name = elements.nameInput.val().trim();
        const age = parseInt(elements.ageInput.val());

        if (!name || isNaN(age) || age < 0) {
          showStatus(elements.setInfoStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„å§“åå’Œå¹´é¾„", "error");
          return;
        }

        try {
          showStatus(elements.setInfoStatus, "æ­£åœ¨è®¾ç½®ä¿¡æ¯...", "info", true);

          const tx = await contract.setInfo(name, age);
          showStatus(
            elements.setInfoStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.setInfoStatus,
            `è®¾ç½®æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.nameInput.val("");
          elements.ageInput.val("");
        } catch (error) {
          console.error("è®¾ç½®ä¿¡æ¯å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          }

          showStatus(
            elements.setInfoStatus,
            `è®¾ç½®å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // è·å–ä¿¡æ¯
      async function getInfo() {
        if (!contract) {
          showStatus(elements.getInfoResult, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(elements.getInfoResult, "æ­£åœ¨è·å–ä¿¡æ¯...", "info", true);
          const result = await contract.getInfo();
          const [name, age] = result;

          if (name && age.toString() !== "0") {
            showStatus(
              elements.getInfoResult,
              `å½“å‰ä¿¡æ¯ - å§“å: "${name}", å¹´é¾„: ${age.toString()}`,
              "success"
            );
          } else {
            showStatus(elements.getInfoResult, "æš‚æ— ä¿¡æ¯æˆ–ä¿¡æ¯ä¸ºç©º", "warning");
          }
        } catch (error) {
          console.error("è·å–ä¿¡æ¯å¤±è´¥:", error);
          showStatus(
            elements.getInfoResult,
            `è·å–å¤±è´¥: ${error.message}`,
            "error"
          );
        }
      }

      // å­˜å…¥ETH
      async function depositEth() {
        if (!contract) {
          showStatus(elements.depositStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.depositAmount.val();

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          showStatus(elements.depositStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„å­˜æ¬¾é‡‘é¢", "error");
          return;
        }

        try {
          showStatus(
            elements.depositStatus,
            `æ­£åœ¨å­˜å…¥ ${amount} ETH...`,
            "info",
            true
          );

          const amountWei = parseEth(amount);
          const tx = await contract.deposit({ value: amountWei });

          showStatus(
            elements.depositStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.depositStatus,
            `å­˜æ¬¾æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.depositAmount.val("");
          await getContractBalance();
        } catch (error) {
          console.error("å­˜æ¬¾å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜äº¤æ˜“è´¹ç”¨";
          }

          showStatus(
            elements.depositStatus,
            `å­˜æ¬¾å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // æå–ETH
      async function withdrawEth() {
        if (!contract) {
          showStatus(elements.withdrawStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.withdrawAmount.val();

        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          showStatus(elements.withdrawStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„æå–é‡‘é¢", "error");
          return;
        }

        try {
          showStatus(
            elements.withdrawStatus,
            `æ­£åœ¨æå– ${amount} ETH...`,
            "info",
            true
          );

          const amountWei = parseEth(amount);
          const tx = await contract.withdraw(amountWei);

          showStatus(
            elements.withdrawStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.withdrawStatus,
            `æå–æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.withdrawAmount.val("");
          await getContractBalance();
        } catch (error) {
          console.error("æå–å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          } else if (error.message.includes("Insufficient balance")) {
            errorMessage = "åˆçº¦ä½™é¢ä¸è¶³";
          }

          showStatus(
            elements.withdrawStatus,
            `æå–å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // è½¬ç§»åˆ°æ‰€æœ‰è€…
      async function transferToOwner() {
        if (!contract) {
          showStatus(elements.transferToOwnerStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(
            elements.transferToOwnerStatus,
            "æ­£åœ¨è½¬ç§»èµ„é‡‘åˆ°æ‰€æœ‰è€…...",
            "info",
            true
          );

          const tx = await contract.transferToOwner();
          showStatus(
            elements.transferToOwnerStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.transferToOwnerStatus,
            `è½¬ç§»æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          await getContractBalance();
        } catch (error) {
          console.error("è½¬ç§»å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("Only the owner")) {
            errorMessage = "åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ";
          } else if (error.message.includes("No balance")) {
            errorMessage = "åˆçº¦æ²¡æœ‰ä½™é¢å¯è½¬ç§»";
          }

          showStatus(
            elements.transferToOwnerStatus,
            `è½¬ç§»å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // é‡ç½®çº¢åŒ…è®¡æ•°å™¨
      async function resetPacketCount() {
        if (!contract) {
          showStatus(elements.transferToOwnerStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        try {
          showStatus(
            elements.transferToOwnerStatus,
            "æ­£åœ¨é‡ç½®çº¢åŒ…è®¡æ•°å™¨...",
            "info",
            true
          );

          const tx = await contract.resetPacketCount();
          showStatus(
            elements.transferToOwnerStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.transferToOwnerStatus,
            `é‡ç½®æˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );
        } catch (error) {
          console.error("é‡ç½®å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("Only owner")) {
            errorMessage = "åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ";
          }

          showStatus(
            elements.transferToOwnerStatus,
            `é‡ç½®å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // åˆ›å»ºçº¢åŒ… - ä¿®å¤å‚æ•°ä¼ é€’é—®é¢˜
      async function createRedPacket() {
        if (!contract) {
          showStatus(elements.createRedPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const amount = elements.redPacketAmountInput.val();
        const count = parseInt(elements.redPacketCountInput.val());

        try {
          // å‚æ•°éªŒè¯
          validateRedPacketParams(amount, count);
          
          debugLog("åˆ›å»ºçº¢åŒ…å‚æ•°éªŒè¯", { amount, count, type: typeof count });

          showStatus(
            elements.createRedPacketStatus,
            `æ­£åœ¨åˆ›å»ºçº¢åŒ…...`,
            "info",
            true
          );

          // é‡è¦ï¼šç¡®ä¿å‚æ•°ç±»å‹æ­£ç¡®
          const isEqual = false;           // å¸ƒå°”å€¼
          const redPacketCount = count;    // æ•´æ•° (1-100)
          const amountWei = parseEth(amount); // BigNumber weiæ ¼å¼

          debugLog("å‘é€äº¤æ˜“å‚æ•°", { 
            isEqual, 
            redPacketCount, 
            amountWei: amountWei.toString(),
            value: amountWei.toString()
          });

          // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„å‚æ•°é¡ºåºå’Œç±»å‹
          const tx = await contract.sendRedPacket(
            isEqual,        // bool
            redPacketCount, // uint8 (1-100)
            amountWei,      // uint256 (wei)
            {
              value: amountWei,  // å‘é€çš„ETHé‡‘é¢ (weiæ ¼å¼)
              gasLimit: 500000   // å¢åŠ Gasé™åˆ¶
            }
          );

          showStatus(
            elements.createRedPacketStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          showStatus(
            elements.createRedPacketStatus,
            `çº¢åŒ…åˆ›å»ºæˆåŠŸï¼åŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          elements.redPacketAmountInput.val("");
          elements.redPacketCountInput.val("1");
          
          // æ›´æ–°åˆçº¦ä½™é¢
          await getContractBalance();
          
          // è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…
          await autoQueryLatestPacket();
          
        } catch (error) {
          console.error("åˆ›å»ºçº¢åŒ…å¤±è´¥:", error);
          debugLog("åˆ›å»ºçº¢åŒ…é”™è¯¯è¯¦æƒ…", error);
          
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage = "ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨";
          } else if (error.message.includes("Count must be between")) {
            errorMessage = "çº¢åŒ…ä¸ªæ•°å¿…é¡»åœ¨1-100ä¹‹é—´";
          } else if (error.message.includes("You can send at most")) {
            errorMessage = "æ‚¨å·²è¾¾åˆ°çº¢åŒ…å‘é€ä¸Šé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜é‡ç½®";
          }

          showStatus(
            elements.createRedPacketStatus,
            `åˆ›å»ºçº¢åŒ…å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯
      async function queryRedPacket() {
        if (!contract) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        const packetId = parseInt(elements.queryPacketIdInput.val());
        
        if (isNaN(packetId) || packetId < 0) {
          showStatus(elements.redPacketStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ID", "error");
          return;
        }

        try {
          showStatus(elements.redPacketStatus, "æ­£åœ¨æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯...", "info", true);
          
          // æŸ¥è¯¢çº¢åŒ…ä¿¡æ¯
          const packetInfo = await contract.getPacketInfo(packetId);
          const [isEqual, count, remainingCount, amount, remainingAmount, hasClaimed] = packetInfo;
          
          // æ›´æ–°UI
          updateRedPacketDisplay(packetId, {
            isEqual,
            count: count.toString(),
            remainingCount: remainingCount.toString(),
            amount: formatEth(amount),
            remainingAmount: formatEth(remainingAmount),
            hasClaimed
          });
          
          currentPacketId = packetId;
          elements.redPacketDetails.removeClass("hidden");
          showStatus(elements.redPacketStatus, "æŸ¥è¯¢æˆåŠŸï¼", "success");
          
        } catch (error) {
          console.error("æŸ¥è¯¢çº¢åŒ…å¤±è´¥:", error);
          let errorMessage = error.message;
          
          if (error.message.includes("Invalid packet ID")) {
            errorMessage = "çº¢åŒ…IDä¸å­˜åœ¨";
          }
          
          showStatus(elements.redPacketStatus, `æŸ¥è¯¢å¤±è´¥: ${errorMessage}`, "error");
          elements.redPacketDetails.addClass("hidden");
        }
      }

      // æ›´æ–°çº¢åŒ…æ˜¾ç¤º
      function updateRedPacketDisplay(packetId, info) {
        // æ›´æ–°åŸºæœ¬ä¿¡æ¯
        $("#packetTitle").text(`çº¢åŒ… #${packetId}`);
        $("#packetType").text(info.isEqual ? "ç­‰é¢çº¢åŒ…" : "éšæœºçº¢åŒ…");
        $("#packetTotalAmount").text(`${info.amount} ETH`);
        $("#packetRemainingAmount").text(`${info.remainingAmount} ETH`);
        $("#packetTotalCount").text(info.count);
        $("#packetRemainingCount").text(info.remainingCount);
        
        // æ›´æ–°å·²æŠ¢çŠ¶æ€
        const claimedText = info.hasClaimed ? "å·²æŠ¢" : "æœªæŠ¢";
        const claimedClass = info.hasClaimed ? "claimed" : "not-claimed";
        $("#packetClaimedStatus").text(claimedText).removeClass("claimed not-claimed").addClass(claimedClass);
        
        // æ›´æ–°è¿›åº¦æ¡
        const totalCount = parseInt(info.count);
        const remainingCount = parseInt(info.remainingCount);
        const claimedCount = totalCount - remainingCount;
        const progressPercent = totalCount > 0 ? (claimedCount / totalCount) * 100 : 0;
        
        $("#progressFill").css("width", `${progressPercent}%`);
        $("#progressText").text(`${claimedCount} / ${totalCount}`);
        
        // æ›´æ–°æŠ¢çº¢åŒ…æŒ‰é’®çŠ¶æ€
        const canClaim = !info.hasClaimed && remainingCount > 0 && parseFloat(info.remainingAmount) > 0;
        
        if (canClaim) {
          elements.claimRedPacketBtn.removeClass("hidden").text("ğŸ æŠ¢çº¢åŒ…").prop("disabled", false);
        } else if (info.hasClaimed) {
          elements.claimRedPacketBtn.addClass("hidden");
        } else if (remainingCount === 0) {
          elements.claimRedPacketBtn.removeClass("hidden").text("ğŸ˜¢ çº¢åŒ…å·²æŠ¢å®Œ").prop("disabled", true);
        } else {
          elements.claimRedPacketBtn.addClass("hidden");
        }
      }

      // è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…
      async function autoQueryLatestPacket() {
        if (!contract) return;
        
        try {
          const latestPacketId = await contract.packetId();
          if (latestPacketId > 0) {
            const targetId = latestPacketId - 1; // packetIdæ˜¯ä¸‹ä¸€ä¸ªè¦åˆ›å»ºçš„IDï¼Œæ‰€ä»¥å‡1
            elements.queryPacketIdInput.val(targetId);
            await queryRedPacket();
          }
        } catch (error) {
          console.log("è‡ªåŠ¨æŸ¥è¯¢æœ€æ–°çº¢åŒ…å¤±è´¥:", error.message);
        }
      }

      // æŠ¢çº¢åŒ…
      async function claimRedPacket() {
        if (!contract) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆè¿æ¥é’±åŒ…", "error");
          return;
        }

        if (currentPacketId < 0) {
          showStatus(elements.redPacketStatus, "è¯·å…ˆæŸ¥è¯¢çº¢åŒ…ä¿¡æ¯", "error");
          return;
        }

        try {
          showStatus(elements.redPacketStatus, "æ­£åœ¨æŠ¢çº¢åŒ…...", "info", true);
          
          const tx = await contract.getRedPacket(currentPacketId, {
            gasLimit: 300000
          });
          
          showStatus(
            elements.redPacketStatus,
            `äº¤æ˜“å·²å‘é€ï¼Œäº¤æ˜“å“ˆå¸Œ: ${tx.hash}`,
            "info"
          );

          const receipt = await tx.wait();
          
          // è§£æäº‹ä»¶è·å–æŠ¢åˆ°çš„é‡‘é¢
          let claimedAmount = "æœªçŸ¥";
          if (receipt.logs) {
            for (const log of receipt.logs) {
              try {
                const parsedLog = contract.interface.parseLog(log);
                if (parsedLog.name === "PacketClaimed") {
                  claimedAmount = formatEth(parsedLog.args.amount);
                  break;
                }
              } catch (e) {
                // å¿½ç•¥è§£æå¤±è´¥çš„æ—¥å¿—
              }
            }
          }
          
          showStatus(
            elements.redPacketStatus,
            `æŠ¢çº¢åŒ…æˆåŠŸï¼è·å¾— ${claimedAmount} ETHï¼ŒåŒºå—å·: ${receipt.blockNumber}`,
            "success"
          );

          // åˆ·æ–°çº¢åŒ…çŠ¶æ€
          await refreshPacketStatus();
          
        } catch (error) {
          console.error("æŠ¢çº¢åŒ…å¤±è´¥:", error);
          let errorMessage = error.message;

          if (error.code === "ACTION_REJECTED") {
            errorMessage = "ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“";
          } else if (error.message.includes("No remaining red packets")) {
            errorMessage = "çº¢åŒ…å·²è¢«æŠ¢å®Œ";
          } else if (error.message.includes("Already claimed")) {
            errorMessage = "æ‚¨å·²ç»æŠ¢è¿‡è¿™ä¸ªçº¢åŒ…äº†";
          } else if (error.message.includes("Invalid packet ID")) {
            errorMessage = "çº¢åŒ…IDæ— æ•ˆ";
          }

          showStatus(
            elements.redPacketStatus,
            `æŠ¢çº¢åŒ…å¤±è´¥: ${errorMessage}`,
            "error"
          );
        }
      }

      // åˆ·æ–°çº¢åŒ…çŠ¶æ€
      async function refreshPacketStatus() {
        if (currentPacketId >= 0) {
          await queryRedPacket();
        }
      }

      // åŠ è½½çº¢åŒ…å†å²
      async function loadRedPacketHistory() {
        if (!contract) {
          elements.redPacketHistory.html('<div class="error">è¯·å…ˆè¿æ¥é’±åŒ…</div>');
          return;
        }

        try {
          elements.redPacketHistory.html('<div class="loading">æ­£åœ¨åŠ è½½çº¢åŒ…å†å²...</div>');
          
          // è·å–æœ€æ–°çš„çº¢åŒ…ID
          const latestPacketId = await contract.packetId();
          
          if (latestPacketId === 0) {
            elements.redPacketHistory.html('<div class="no-data">æš‚æ— çº¢åŒ…å†å²</div>');
            return;
          }

          let historyHtml = '<div class="history-list">';
          
          // åŠ è½½æœ€è¿‘çš„10ä¸ªçº¢åŒ…ï¼ˆæˆ–å…¨éƒ¨ï¼Œå¦‚æœå°‘äº10ä¸ªï¼‰
          const maxHistory = Math.min(latestPacketId, 10);
          
          for (let i = latestPacketId - 1; i >= Math.max(0, latestPacketId - maxHistory); i--) {
            try {
              const packetInfo = await contract.getPacketInfo(i);
              const [isEqual, count, remainingCount, amount, remainingAmount, hasClaimed] = packetInfo;
              
              const totalCount = count.toString();
              const claimedCount = parseInt(totalCount) - parseInt(remainingCount.toString());
              const progressPercent = parseInt(totalCount) > 0 ? (claimedCount / parseInt(totalCount)) * 100 : 0;
              const status = parseInt(remainingCount.toString()) === 0 ? "å·²æŠ¢å®Œ" : hasClaimed ? "å·²å‚ä¸" : "å¯æŠ¢";
              const statusClass = parseInt(remainingCount.toString()) === 0 ? "finished" : hasClaimed ? "claimed" : "available";
              
              historyHtml += `
                <div class="history-item ${statusClass}" onclick="loadPacketDetails(${i})">
                  <div class="history-header">
                    <span class="packet-id">çº¢åŒ… #${i}</span>
                    <span class="packet-status ${statusClass}">${status}</span>
                  </div>
                  <div class="history-details">
                    <div class="detail-item">
                      <span>ç±»å‹: ${isEqual ? "ç­‰é¢" : "éšæœº"}</span>
                      <span>æ€»é¢: ${formatEth(amount)} ETH</span>
                    </div>
                    <div class="detail-item">
                      <span>è¿›åº¦: ${claimedCount}/${totalCount}</span>
                      <span>å‰©ä½™: ${formatEth(remainingAmount)} ETH</span>
                    </div>
                  </div>
                  <div class="progress-bar-small">
                    <div class="progress-fill-small" style="width: ${progressPercent}%"></div>
                  </div>
                </div>
              `;
            } catch (error) {
              console.error(`åŠ è½½çº¢åŒ… #${i} å¤±è´¥:`, error);
            }
          }
          
          historyHtml += '</div>';
          elements.redPacketHistory.html(historyHtml);
          
        } catch (error) {
          console.error("åŠ è½½çº¢åŒ…å†å²å¤±è´¥:", error);
          elements.redPacketHistory.html(`<div class="error">åŠ è½½å¤±è´¥: ${error.message}</div>`);
        }
      }

      // åŠ è½½ç‰¹å®šçº¢åŒ…è¯¦æƒ…
      function loadPacketDetails(packetId) {
        elements.queryPacketIdInput.val(packetId);
        queryRedPacket();
      }

      // ç›‘å¬è´¦æˆ·å’Œç½‘ç»œå˜åŒ–
      if (window.ethereum) {
        window.ethereum.on("accountsChanged", (accounts) => {
          if (accounts.length === 0) {
            disconnectWallet();
          } else if (currentAccount && accounts[0] !== currentAccount) {
            connectWallet();
          }
        });

        window.ethereum.on("chainChanged", () => {
          window.location.reload();
        });
      }

      // äº‹ä»¶ç›‘å¬å™¨è®¾ç½®
      $(document).ready(function () {
        // ç»‘å®šäº‹ä»¶
        elements.connectWallet.on("click", connectWallet);
        elements.disconnectWallet.on("click", disconnectWallet);
        elements.setInfoBtn.on("click", setInfo);
        elements.getInfoBtn.on("click", getInfo);
        elements.depositBtn.on("click", depositEth);
        elements.withdrawBtn.on("click", withdrawEth);
        elements.createRedPacketBtn.on("click", createRedPacket);
        
        // çº¢åŒ…ç›¸å…³äº‹ä»¶
        elements.queryRedPacketBtn.on("click", queryRedPacket);
        elements.claimRedPacketBtn.on("click", claimRedPacket);
        elements.refreshPacketBtn.on("click", refreshPacketStatus);
        elements.loadHistoryBtn.on("click", loadRedPacketHistory);

        // å›è½¦é”®æ”¯æŒ
        elements.nameInput.add(elements.ageInput).on("keypress", function (e) {
          if (e.which === 13) setInfo();
        });

        elements.depositAmount.on("keypress", function (e) {
          if (e.which === 13) depositEth();
        });

        elements.withdrawAmount.on("keypress", function (e) {
          if (e.which === 13) withdrawEth();
        });

        elements.redPacketAmountInput.add(elements.redPacketCountInput).on("keypress", function (e) {
          if (e.which === 13) createRedPacket();
        });

        elements.queryPacketIdInput.on("keypress", function (e) {
          if (e.which === 13) queryRedPacket();
        });

        // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
        if (checkMetaMask()) {
          window.ethereum
            .request({ method: "eth_accounts" })
            .then((accounts) => {
              if (accounts.length > 0) {
                connectWallet();
              }
            })
            .catch((error) => {
              console.error("æ£€æŸ¥è¿æ¥çŠ¶æ€å¤±è´¥:", error);
            });
        }
      });
    </script>
  </body>
</html>